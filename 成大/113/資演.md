1. ![[Pasted image 20260115124043.png]]
	1. [ANS: D] BST insert nodes
		```
		[insert]
		15
		8, 18
		6, 13, 17, null
		5, 11, null, 14, null, null, null, null
		
		[delete 15]
		largest in left subtree: 14
		smallest in right subtree: 18
		```
	1. [ANS: D] BST delete nodes
1. ![[Pasted image 20260115130205.png]]![[Pasted image 20260115130226.png]]
	1. [ANS: D] max heap
		```
		[insert] 20,5,10,18,4,22,11,32,21
		32
		22,20
		21,4,10,11
		5,18,null,null,null,null,null,null 
		```
	2. [ANS: B] min heap
		```
		[insert] 20,5,10,18,4,22,11,32,21
		4
		5,10
		20,18,22,11
		32,21,null,null,null,null,null,null
		```
	3. [ANS: ] symmetric min-max heap
2. ![[Pasted image 20260115134528.png]]
	1. [ANS: B]
		```
		re-construct binary tree
		
		[method]
		1. 用 posfix 找 root
		2. 再去 infix 標記 root, 即可分出 left-subtree / right-subtree
		3. 再去 posfix 去區分哪些是 left-subtree / right-subtree
		4. 回到 1, recursively 找 subtree 的 root
		
		[list representation]
		Q,Y,R,Z,L,K,W,NULL,NULL,P,C,NULL,NULL,NULL,S
		
		[pre-order]
		Q,Y,Z,L,P,C,R,K,W,S
		```
	1. [ANS: A]
1. ![[Pasted image 20260115143855.png]] ![[Pasted image 20260115143840.png]]
	1. [ANS: ] BFS, DFS
	2. [ANS: ] MST
2. hash function : bloom filter![[Pasted image 20260115144506.png]]![[Pasted image 20260115144528.png]]
	1. [ANS: ]
3. leftist tree ![[Pasted image 20260115152731.png]]
	1. [ANS: ] delete minimum element from the leftist tree
4. fibonacci heap ![[Pasted image 20260115153620.png]]![[Pasted image 20260115153643.png]]
5. red-black tree ![[Pasted image 20260115153718.png]]![[Pasted image 20260115153745.png]]![[Pasted image 20260115153803.png]]![[Pasted image 20260115153816.png]]
6. B+ tree ![[Pasted image 20260115153850.png]]![[Pasted image 20260115153907.png]]
7. bianry trie -> patricia ![[Pasted image 20260116135753.png]]![[Pasted image 20260116135813.png]]![[Pasted image 20260116135836.png]]![[Pasted image 20260116135857.png]]
8. matrix multiplication (recursively) ![[Pasted image 20260116140138.png]]
	```
	A = | A_11, A_12 |
		| A_21, A_22 |
		
	B = | B_11, B_12 |
		| B_21, B_22 |
		
	matrix addition : O(n^2)
	
	T(n) = 4T(n/2) + O(n)
	
	master theorem : log_2^(4) = 2 => O(n^2) > O(n)
	Hence, T(n) = O(n^2)
	```
	1. Q: what is the T(n) ? A: T(n)  
	