1. ![[Pasted image 20260122141906.png]]
	1. [ANS: A]
2. ![[Pasted image 20260122142522.png]]
	1. [ANS: C] 跳過 x
3. ![[Pasted image 20260122143113.png]]
	1. [ANS: AE]
		1. (B) heap sort worst : O(nlogn); quick sort worst : O(n^2) -> pick bad pivot (pivot is always the smallset or largest)
			1. 但是這裡是用 faster, 而不是用 has better worst-case time complexity -> 所以是 `false`
		2. (C) left child : 2 * i , right child : 2 * i + 1
4. ![[Pasted image 20260122152925.png]]
	1. [ANS: B]
		1. 1 個 position 4 bytes
		2. 5(5 position in a row) * 3(3 rows) * 4 + 2 * 4 = 68
		3. 0x7ffd9e21bc00 + 44(decimal : 68) = 0x7ffd9e21bc44
5. heap sort : max heap property ![[Pasted image 20260122153926.png]]
	1. [ANS: E] 10, 8, 9, 4, 5, 7, 6, 3, 2 | 14
	2. Note : heapify 是由 root 往下做 max-heapfiy check 的
6. ![[Pasted image 20260122155214.png]]![[Pasted image 20260122155229.png]]
	```
	Cost = 1 + 2 + 3 + 4 + 5 + 8 = 23
	
	Kruskal : AB, AG, GE, ED, CG, AF
	Prim : AF, AB, AG, GE, ED, GC
	```
	1. [ANS: E]
	2. [ANS: C]
	3. [ANS: A]
1. ![[Pasted image 20260123215458.png]]
	```
	AVL tree: 
	30
	10, 60
	5, 20, 45, null
	null, null, null, 25, 40, 50
	```
	1. [ANS: A]
	2. [ANS: D]
	3. [ANS: E] RR, RR, LL, LR
2. ![[螢幕擷取畫面 2026-01-23 231836.png]]
	```
	[30]
	[10] [50]
	[5] [20,25] [40,45] [60,70]
	```
	1. [ANS: B] 60 + 70 = 130
	2. [ANS: C] root sum = 30
	3. [ANS: A] # split = 3
3. Dijkstra ![[Pasted image 20260124202119.png]]![[Pasted image 20260124202201.png]]
	1. [ANS: ]
	2. [ANS: ] 
	3. [ANS: D] O(n^2)
4. random quick sort (random choose pivot) ![[Pasted image 20260124203253.png]]
	1. [ANS: C]  average case : O(n*logn)
	2. [ANS: C] 夠 balanced -> pivot 落在 n/3 ~ 2n/3, 而這個區間的元素數量 n/3。機率 (n/3) / n = 1/3
	3. [ANS: B] geometric distribution : 成功機率 P = 1/3, 期望值 E = 1/P = 3
5. fully parentheses (對應 matrix-chain multiplication) ![[Pasted image 20260124225956.png]]![[Pasted image 20260124230015.png]]
	1. [ANS: ]
	2. [ANS: ]
	3. [ANS: ]