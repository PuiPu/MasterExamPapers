[交大 資演 109](https://hackmd.io/@2JWhhRZqQnKGndRWNWcAlQ/rkmsZ6vji)

1. connected, articulation point ![[Pasted image 20260106164600.png]]
	1. [ANS: ]
	2. [ANS: ]
2. graph k-coloring ![[Pasted image 20260106164617.png]]
	> super-polynomial time : superpolynomial function is higher(faster) than any polynomial function [super-polynomail wiki](https://zh.wikipedia.org/zh-tw/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
	1. [ANS: B] k = 2, BFS/DFS
		1. BFS : adjacent list O(V+E), adjacent matrix O(V^2)
	2. [ANS: E] k $\ge$ 2, NP-complete
	3. [ANS: E] k $\ge$ 2, NP-complete
3. Hamiltonain with constrained (using reduction) ![[Pasted image 20260106164629.png]] ![[Pasted image 20260106164647.png]]
	1. [ANS: ]
	2. [ANS: ]
	3. [ANS: ]
	4. [ANS: ]
4. B-tree ![[Pasted image 20260106164702.png]]
	1. [ANS: ]
	2. [ANS: ]
5. minimum spanning tree ![[Pasted image 20260106164720.png]]
	1. [ANS: ]
	2. [ANS: ]
6. graph: find path with constrained ![[Pasted image 20260106164739.png]]
	1. [ANS: ]
	2. [ANS: ]
	3. [ANS: ]
7. disjoint set ![[Pasted image 20260106164756.png]]
	1. [ANS: ]
	2. [ANS: ]
	3. [ANS: ]
8. solve recursion (fast multiplication)![[Pasted image 20260106164813.png]]
	```
	1. 
	   (A) a2=13, (1 + 2*sqrt(3))^2 = 13 + 4*sqrt(3)
	   (B) b3=30, (1 + 2*sqrt(3))^3 = (13 + 4*sqrt(3)) * (1 + 2*sqrt(3)) = 37 + 30*sqrt(3)
	   (C) a5=a4+6*b4, (1 + 2*sqrt(3))^5 = (a4 + b4*sqrt(3)) * (1 + 2*sqrt(3)) = (a4 + 6*b4) + (2*a4 + b4)*sqrt(3)
	   (D) b5=2*a4+6*b4
	   (E) for some finite n, n is integral
	
	2. 
	   (a_n + b_n*sqrt(3))^2 = a_n^2 + 3*b_n^2 + 2*sqrt(3)*a_n*b_n = (1 + 2*sqrt(3))^(2n)
	   
	   -> a_(2n) = a_n^2 + 3*b_n^2 
			:= a_n = a_(n/2)^2 + 3*b_(n/2)^2
		  
	   -> b_(2n) = 2*a_n*b_n
			:= b_n = 2*a_(n/2)*b_(n/2)
	   
	   (A) algo.2 is most efficient to compute a_n & b_n ? NOPE
	   (B) ODD : calculate P(n-1);
		   EVEN : a_n = a_(n/2)^2 + 3*b_(n/2)^2
		   T(n) = O(logn)
	   (C) a_n & b_n must be integral
	   (D)
	   (E) odd 沒有辦法加速，只有 even 可以
	```
	1. [ANS: BC]
	2. [ANS: B] T(n) = T(n-1) + 1 -> worst case time complexity : O(n)
	3. [ANS: BD] 
9. greedy ![[Pasted image 20260106164829.png]]
	1. [ANS: E  ]
	2. [ANS: ]
	3. [ANS: ]
10. hash, heap, AVL tree![[Pasted image 20260106164842.png]]
	1. [ANS: ADE]
		1. (A) load factor $\alpha$ = n / m, n=資料數量, m=slot個數, 也就代表每個 slot 平均會被分配到 $\alpha$ 個 items。hash 的複雜度是 O(1)，所以 average search time O(1+m)
		2. (B) heap search : O(n) -> 仍然需要 iterate 所有的 items
		3. (C) ?
		4. (D) AVL tree 是 balanced BST
		5. (E) red node 的 left/right subtree 必定為 black 
11. order of growth for sorting algo. ![[Pasted image 20260106164853.png]]
	1. [ANS: D] bubble sort : worst time complexity O(n^2)
	2. [ANS: B] heap sort : worst time complexity O(nlogn)
12. ![[Pasted image 20260106164910.png]]
	1. [ANS: ]
	2. [ANS: ]
	3. [ANS: ]
13. max heap ![[Pasted image 20260106164928.png]]
	```
	(using level ordering)
	before          : 27,19,21,13,17,11,10,9,7,8  
	after insert 35 : 35,27,21,13,19,11,10,9,7,8,17
	
	operation:
		1. insert at last
		2. maintain max-heap property (every sub tree is max-heap) -> like bubble-up to verify root is the largest, if not, exchange with parent
	```
	1. [ANS: C]
	2. [ANS: E]
1. binary search tree (deletion 的 find successor/predecessor) ![[Pasted image 20260106164941.png]]
		```
		[algo.]
			1. if x.right != null, find minimum node from subtree rooted by x.right
			2. else, keep pop-up until reach root (y = p[x] & x = y.right, with BST property, y < x)
		```
	1. [ANS: A]
		1. (A) y must be successor of x (inorder successor : x = y.right -> sequence = y.left, y, y.right=x)
		2. (C) x must be the maximum node of a sub-tree rooted at node y -> `wrong, x 的 right subtree 都比它大`
		3. (D) y must be the minimum node of a sub-tree rooted at node x ->`wrong, 只有當 right[x] != NIL 是這樣，在 while 裡面不是這樣`
		4. (E) y must be the parent of node x -> `wrong, 只有在 while-loop 裡面是這樣` 
2. circular double linked list ![[Pasted image 20260106164952.png]]
	```
	insert : 3,4,5,9,7,3 ...
	total steps : (2020-1) * 2(2 setps) = 4038
	
	1. 4038 % 5 = 3
	2. x = 5
	3. x.prev.prev = 7
	```
	4. [ANS: E]
 