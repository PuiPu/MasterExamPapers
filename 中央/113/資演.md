1. ![[Pasted image 20260112134908.png]]
	```
	[Kruskal's rule] : edges 由小到大排列，必須先從小的邊開始選，選的時候不能形成 cycle
	
	(edge weight, edges)
	1 : ab, df
	2 : bf, cd, cf
	3 : bc, de
	4 : bd, ce
	5 : ef
	6 : ac
	   
	[Note. 我卡住的點]
	我以為要自己 enumerate 所有的可能，但是其實只要看選項有沒有違反就好了
	
	---
	(A) df:1, ab:1, dc:2, bf:2, de:3 -> accept 
	(B) df:1, ab:1, bf:2, de:3, dc:2 -> deny (edge 小的要先選)
	(C) ab:1, df:1, bf:2, fc:2, de:3 -> accept
	(D) ab:1, df:1, dc:2, fc:2, de:3 -> deny (cycle cdf)
	```
	2. [ANS: BD]
1. ![[Pasted image 20260113131915.png]]
	1. [ANS: AB]
	2. (A) best case of insertion (near sorted) : O(n)
	3. (B) ASCII charateristic 範圍固定 (k = 128 or 256), string sort 在 fixed-length, radix-sort 是非常有效的
	4. (C) 只有 radix sort 不是 comparison sort, 其他都是(note. insertion sort 是 comparison based)
	5. (D) stable sort : insertion sort, merge sort, radix sort (如果 internal sort 是 stable); not stable : heap sort, quick sort
2. ![[Pasted image 20260113134429.png]]
	1. [ANS: BC]
	2. (A) 2*T(n/2) 代表左右子樹都要處理(tree traversal/merge sort)，binary search 一次只做一邊 subtree
	3. (B) BST degenerate 成 skew tree (DS textbook 裡面有提到，再看)
	4. (D) insertion 最多只會一層，不會有跳兩層的情況出現 T(n-2)
3. ![[Pasted image 20260113134836.png]]
	1. [ANS: AB]
		1. 